---
title: "Introduction to ggplot"
author: Joshua Megnauth
output:
  github_document:
    df_print: paged
    toc: true
---

# Introduction

Ggplot follows the philosophy of the grammar of graphics which is based off of the [epynonymous book](https://www.springer.com/gp/book/9780387245447) by Leland Wilkinson. Grammer of graphics refers to an intuition about plots based on the elements that construct a graph. The interface allows a programmer and statistician to construct a plot by working on units such as layers or lines. I'm a huge Python fan, but I'm firmly in the ggplot camp over Matplotlib/Seaborn. Matplotlib mimics a Matlab interface which feels entirely unintuitive in Python.

The graphs below aren't great by the way. I'll explain the problems with the graphs so **please don't take these as examples of perfect or amazing graphs.** They're not. I mostly wish to demonstrate how to use ggplot step by step. Professor Cohen's visualization lecture discusses the flaws of specific graphs. Check his Rmd/lecture out to gain an intuition on creating informative graphs.

Anyway! I'll write a very basic guide to using ggplot. Check out the [documentation](https://ggplot2.tidyverse.org/) if you wish to learn more.

# Basics
```{r pokemon_data, message=FALSE, warning=FALSE}
library(kableExtra)
library(tidyverse)
library(ggplot2)

pokemon_df <- read_csv("Pokemon_data.csv")
```

Don't worry if you know little about Pokémon. Pokémon is not a prerequisite to my tutorial. Also, I'm not cleaning or wrangling this data in order to save time. You should always clean your data regardless.

The two major parts of ggplot are **aesthetics** and **layers.** Take a look at the **ggplot()** function's help page with `?ggplot` in your console. The **ggplot()** function essentially takes two parameters: your data and your aesthetic mapping.

Next let's take a look at `?aes` for help on the aesthetics function. The manual explains that the function takes in parameters in the form `aesthetic = variable` where _variable_ is a variable/column in your data and _aesthetic_ refers to visual aspects of the plot itself. Finally, the documentation mentions that **ggplot()** is "almost always followed by +" to add layers.

Admittedly, these concepts are a bit abstract. Watching ggplot in action would help you understand how the objects fit together. Take a gander at the data before we begin so you have an idea how everything looks.

```{r head}
head(pokemon_df) %>%
  kable()
```

## An example
```{r attack_spatk_scatter}
ggplot(pokemon_df, aes(x = attack, y = sp_attack)) +
  geom_point()
```

The above plot demonstrates what we discussed above. First, I call **ggplot()** by passing in my data, **pokemon_df.** The second argument is an aesthetic mapping that maps `attack` to `x` and `sp_attack` to `y`; both of those are columns in my data, of course. The x and y axis are not the only aesthetics. My favorite aesthetic (not including x and y) is color which we'll look at in a bit.

After calling ggplot we have to provide layers to do the actual plotting. The function **geom_point()** creates a scatter plot based on the aesthetics provided to **ggplot()** _or_ to aesthetics provided to **geom_point().** This distinction is important, but we can't discuss it just yet.

Scatter plots are useful for showing how two variables change in respect to each other. For example, a Pokémon with 90 base H.P. and 100 base defense would have a point at (90, 100). Scatter plots require two continous variables (or discrete treated as continous in this case).

Anyway, with that we have our basic, untitled, and decidedly gray plot! Before we look at ways to potentially make our plot look better, let's take a quick look at saving our plot to a variable.

## Storing a ggplot object into a variable
```{r figureobj_noshow}
weight_density <- ggplot(pokemon_df, aes(log(weight_kg))) +
  geom_density(fill = "#bd93f9", color = "#282a36")
```

Notice that our plot doesn't display at all. We're storing our ggplot object in a variable for later use. We can continue to modify our variable if we wish: 

```{r figureobj_addtitle}
weight_density <- weight_density +
  ggtitle("Pokémon weight distribution (log kilograms)")
```

We simply print the variable when we're ready to display our plot.

```{r figureobj_show}
weight_density
```

You may store your plots in a variable to display later or simply display them right after you code without the variable step.

Also, notice that you may call functions, such as **log()**, to transform your variables right in your ggplot pipeline.

# Aesthetics---colors, titles, shapes, and more!

The ggplot library allows simple additions of more aesthetics. Take a look at our call to **ggplot()** where we map `attack` and `sp_attack` to `x` and `y` respectively. The color aesthetic maps a variable onto a color. The levels of a categorical variable take on separate colors while continous variables are mapped to a gradient.

How would we map the variable `type1` to `color`? (And yes. I'm totally aware I did it above!) Try creating the graph yourself---that is, remaking the graph above but adding the color aesthetic as well.

```{r attack_spatk_type_scatter, message = FALSE}
ggplot(pokemon_df, aes(attack, sp_attack, color = type1)) +
  geom_point()
```

Adding the color aesthetic is as simple as passing in the unquoted name of a column to `color`. Notice that I didn't write `x = attack, y = sp_attack`. The first two arguments are `x` and `y` which means we may pass in parameters by position as discussed in my microtutorial on functions. The color aesthetic works fine with discrete or continous variables.

We can also overlay plots (hence why they're known as layers) as well as add titles and axis labels. Let's use two different variables to demonstrate the above.

```{r hp_defense_scatter, message = FALSE}
ggplot(pokemon_df, aes(hp, defense, color = type1)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE) +
  ggtitle("Pokémon: defense versus health") +
  xlab("Base hit points") +
  ylab("Base defense")
```

The above plot is totally flawed but useful to show how to add titles, labels, and additional layers. Adding an extra layer is as simple as adding your original layer. I added a series of regression lines to the plot with **geom_smooth().** The `method` argument to **geom_smooth()** refers to which function ggplot calls to create the regression line(s) which is unfortunately out of scope for this microtutorial at the moment. I only wanted one regression line, however, so we'll fix that up in the next section.

The functions **ggtitle()**, **xlab()**, and **ylab()** set the title, x axis label, and y axis label respectively. The functions have additional features, such as setting subtitles, so be sure to check the manual!

As a bit of an aside, I love how we can see the individual regression lines being pulled toward the outliers.

## Improving our scatter plot
The scatter plot above is a bit of a mess. A regression line would be nice, but we managed to add a line for each type! The `color` aesthetic maps the variable onto, well, color! For scatter plots, mapping a variable onto color is useful because each level of the categorical is often clearly represented in the plot. However, for regressions the color aesthetic calculates a regression for each level of the categorical! In some cases you'd want multiple regressions (something like parallel slopes) in order to represent different trends. However, in our case we have a line per primary type that are all fairly clustered together.

Another problem is that our plot exhibits a lot of overplotting. In other words, many of our points overlap due to the clustering of our data. We can add a jitter using **geom_jitter()** and an alpha (transparency) to help.

```{r hp_defense_scatter_better, message = FALSE}
ggplot(pokemon_df) +
  geom_jitter(aes(hp, defense, color = type1), alpha = 0.5) +
  geom_smooth(aes(hp, defense), color = "midnightblue", method = lm,
              se = FALSE) +
  ggtitle("Pokémon: defense versus health") +
  xlab("Base hit points") +
  ylab("Base defense") +
  scale_x_continuous(breaks = scales::extended_breaks(11)) +
  scale_color_discrete(name = "Primary type") +
  theme_minimal()
```

The **geom_jitter()** function adds a reasonable amount of random noise to each point to alleviate overplotting. In this case, the jitter only marginally helped. An alpha parameter also helps us visualize the data a bit by adding a transparency to the hues. More opaque spots contain more overlapped observations. In any case, our plot is still fairly overplotted due to some Pokémon---like Chancey which has a high base H.P. but low base defense. Outliers, or at least strange observations, can mess up the aesthetics of your plot in a way that clouds your intention. I personally don't like removing observations unless they're outright wrong, so I'd opt to show two graphs depending on my audience. In fact, I actually learned something because I didn't know some Pokémon had such weird base stats till I saw my _own graph!_

**With that said, the graph above is still a mess but I'm mostly trying to demonstrate using ggplot here.**

Next let's look at the `scale_*` functions. To quote the [ggplot2](https://ggplot2-book.org/scales.html) book: 

> Scales in ggplot2 control the mapping from data to aesthetics. They take your data and turn it into something that you can see, like size, colour, position or shape. They also provide the tools that let you interpret the plot: the axes and legends. You can generate plots with ggplot2 without knowing how scales work, but understanding scales and learning how to manipulate them will give you much more control.

The ggplot library has _many_ `scale_*` functions to cover different aspects of the plots. They're usually named **scale_[plot element]_[interval, such as discrete].** The original plot had a wonky x scale that barely covered the numbers represented in the data---partially due to the outliers stretching the scale, by the way. The scale **scale_x_continuous()** refers to a continuous x axis like the name implies. The parameter `breaks` refers to the tick marks that are shown on the bottom of the plot. I set the ticks using the **extended_breaks()** function to cover the entire range of `hp`. The scale **color_discrete** refers to color as mapped by a discrete variable. In our case the `type1` variable is categorical and therefore also discrete. The `name` parameter references the name of the scale which is "type1" by default due to our variable. I renamed it to "Primary type" which looks cleaner.

Finally, notice that the call to **aes()** is outside of the call to **ggplot()**. You can map aesthetics in the geom functions instead of (or in addition to) **ggplot()** if you want to override the mapping. Also notice that `alpha` for **geom_jitter()** and `color` for **geom_smooth()** are set outside of aes. Aesthetics set inside **aes()** refer to variables in your data while aesthetics set outside of **aes()** are general instead of referring to your data. For example, if you want to map a color to your data where the color _is not based on a variable_ then you must put the `color` aesthetic outside of your call to **aes()**.

## Zooming in with xlim/ylim and setting a custom color scale

One major issue with the plot above is that we don't use the official type colors for Pokémon. Sometimes we'd like to map a color to a factor rather than sticking with the defaults or using another scale provided by R. Doing so is more tedious than difficult. First, we have to define all of our colors. I'm using the hexadecimal colors from [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Category:Type_color_templates).

```{r hp_defense_scatter_awesome, message = FALSE, warning = FALSE}
# Our actual colors from Bulbapedia and based on another project I'm working on
type_colors <- c("Water" = "#6890F0",
                 "Fire" = "#F08030",
                 "Grass" = "#78C850",
                 "Electric" = "#F8D030",
                 "Ice" = "#98D8D8",
                 "Psychic" = "#F85888",
                 "Dragon" = "#7038F8",
                 "Dark" = "#705848",
                 "Fairy" = "#EE99AC",
                 "Normal" = "#A8A878",
                 "Fighting" = "#C03028",
                 "Flying" = "#A890F0",
                 "Poison" = "#A040A0",
                 "Ground" = "#E0C068",
                 "Rock" = "#B8A038",
                 "Bug" = "#A8B820",
                 "Ghost" = "#705898",
                 "Steel" = "#B8B8D0",
                 "Unknown" = "#68A090")
# IGNORE THIS
temp <-
  pokemon_df %>%
  lm(defense ~ hp, .) %>%
  coef() %>%
  map_dbl(~ .x)
hp_def_equation <- paste("y = ",
                         round(temp[1], 3),
                         " + ",
                         round(temp[2], 3),
                         "x",
                         sep = "")
# OKAY YOU MAY CONTINUE

ggplot(pokemon_df) +
  geom_jitter(aes(hp, defense, color = type1), alpha = 0.7) +
  geom_smooth(aes(hp, defense), color = "midnightblue", method = lm,
              se = FALSE) +
  annotate("text", x = 50, y = 6, label = hp_def_equation) +
  ggtitle("Pokémon: defense versus health") +
  xlab("Base hit points") +
  ylab("Base defense") +
  xlim(0, 150) +
  ylim(0, 150) +
  scale_color_manual(values = type_colors, name = "Primary type") +
  theme_minimal()
```

The final graph is still a bit messy as we have _a lot_ of colors. The colors technically **don't add anything useful,** but I like seeing that types don't have an association with defense versus health. The regression line is fitted to the entire data since I only zoomed into the plot using `xlim` and `ylim`. You may filter the data instead to regress only on the bulk of the observations.

Here's a (perhaps?) cleaner way to visualize defense versus hit points. Setting hollow shapes helps with overplotting and the possibly distracting colors are removed. I'm not great at art or visualizations, so don't take either of these graphs as "correct."
```{r filtered_scatter, message=FALSE, warning=FALSE}
pokemon_df %>%
  filter(hp <= 150 & defense <= 150) %>%
  ggplot(aes(hp, defense)) +
  geom_point(color = "#ff5555", shape = 1) +
  geom_smooth(method = lm, color = "#282a36", se = FALSE) +
  annotate("text", x = 50, y = 6, label = hp_def_equation) +
  ggtitle("Pokémon: defense versus health") +
  xlab("Base hit points") +
  ylab("Base defense") +
  theme_minimal()
```

## An aside on types
You should always be aware of your data set's types when coding in R (and also Python). Scroll up and take a look at the `generation` variable in the data set. The type is listed as numbers and is casted as an integer. Pokémon are introduced in every generation which in turn corresponds to new mainline games. In other words, a Pokémon's generation isn't exactly a number but a categorical/nominal variable.

I'll have to write a longer explanation of this phenomenon, but you may think of the concept of a zip code. Zip codes are "numbers" but they're technically categorical. You can't add, subtract, divide, et cetera different zip codes. If R attempts to use zip codes as a number you'd encounter all sorts of extremely strange problems. I shall demonstrate in another guide. For now let's type cast some of our variables.

You may convert variables to factors in base R as so: 

```{r baser_type, eval=FALSE}
pokemon_df$generation <- as.factor(pokemon_df$generation)
```

Or you may use [dplyr](https://dplyr.tidyverse.org/) like so: 
```{r dplyr_type}
pokemon_df <-
  pokemon_df %>%
  mutate(generation = as_factor(.$generation),
         base_egg_steps = as_factor(.$base_egg_steps),
         is_legendary = as_factor(.$is_legendary),
         is_mythical = as_factor(.$is_mythical),
         is_mega = as_factor(.$is_mega))
# Et cetera...
```

# A quick look at different graph types
## Bar plots
```{r barplot}
ggplot(pokemon_df, aes(generation)) +
  geom_bar(color = "#282a36", fill = "#50fa7b") +
  ggtitle("Pokémon introduced each generation") +
  xlab("Generation") +
  ylab("Frequency")
```

Bar plots work best when you have a categorical variable. Categorical/nominal variables are countable, and bar plots graph those counts.

## Histograms

Histograms plot the distribution of continous variables. You can think of them as bar plots for continous data. The data are placed into bins so that a range of values fit into each bin. This process is sensible of course. If you had values such as: 
```{r example_hist}
test_data <- tibble(numbers = rnorm(200, mean = 10, sd = 5))
head(test_data, 25) %>%
  kable()
```

The values would be placed into ranged bins such as [0, 2], (2, 4], (4, 6), et cetera.
